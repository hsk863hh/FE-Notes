## 拷贝
在js里，拷贝有2种，`深拷贝`和`浅拷贝`。在具体说明之前，先解释下什么是拷贝。
拷贝，另外一种说法就是复制。但是复制怎么会有深和浅的区别呢？这就涉及不同的数据类型在复制时的表现了。
如果是基础数据类型(Number、String、Boolean、Null、Undefined、Symbol)，存储在栈内存中，在做赋值操作时，直接复制值，这样复制出的新变量和原变量就完全无关了。

```js
let a = 1;
let b = a;
b = 2;
console.log(a,b); // 1,2
```

如果是引用类型(包括普通对象、数组、日期、正则等)，存储在堆内存中，变量仅保存堆内存的引用地址（指针）。在赋值操作时，只是复制地址，这样复制出的新变量和原变量就指向同一个对象了。

```js
let obj1 = {x: 1}; 
let obj2 = obj1; 
obj2.x = 2; 

console.log(obj1.x, obj2.x); // 2,2
```

## 浅拷贝（Shallow Copy）
仅复制对象的表层结构（即对象本身的属性），但如果属性值是引用类型（如嵌套对象、数组），则不会复制嵌套内容，而是直接复用原引用。

### 特点：
- 只复制第一层数据，嵌套的引用类型仍共享内存。
- 修改嵌套内容时，原对象和拷贝对象会互相影响。

### 常见浅拷贝方法：
1.对象浅拷贝：
- Object.assign({}, 原对象)
- 扩展运算符 { ...原对象 }

2.数组浅拷贝：
- 数组.slice()
- 数组.concat()
- 扩展运算符 [...原数组]

```js
// 原对象（包含嵌套对象）
const obj = {
  name: '张三',
  info: { age: 20 } // 嵌套引用类型
};

// 浅拷贝
const shallowCopy = { ...obj };

// 修改表层属性（值类型）：互不影响
shallowCopy.name = '李四';
console.log(obj.name); // 仍为 '张三'（正确）

// 修改嵌套属性（引用类型）：互相影响
shallowCopy.info.age = 30;
console.log(obj.info.age); // 变成 30（问题所在）
```

## 手动实现一个浅拷贝函数
实现要求
- 只拷贝对象或数组的第一层内容
- 不处理嵌套对象的深层拷贝
- 支持对象和数组两种数据类型
- 保持原始数据类型不变

```js
function shallowClone(obj, depth) {
  if(depth > 1) {
    return obj
  }
  if(typeof obj !== 'object' && obj !== null) {
    return obj;
  }
  if(Array.isArray(obj)) {
    const arr = []
    obj.forEach((item, index) => {
      arr[index] = shallowClone(item, depth + 1)
    })
    return arr
  }else {
    const newObj = {}
    for(let key in obj) {
      newObj[key] = shallowClone(obj[key], depth + 1)
    }
    return newObj
  }
}

const obj = {a: 1, b: {c: 2}}
const copy1 = shallowClone(obj, 1) 
copy1.a = 10
copy1.b.c = 20

console.log(obj);

const arr = [1, [2, 3]];
const copy2 = shallowClone(arr, 1);
copy2[0] = 10;
copy2[1][0] = 20;

console.log(arr);
```