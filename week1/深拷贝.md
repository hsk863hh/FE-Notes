## 什么是深拷贝
上一章讲了什么是浅拷贝以及js原生的浅拷贝方法，最后还手动实现了一个浅拷贝函数。但是浅拷贝有个缺点，在拷贝嵌套对象时，会有问题。

如果我们想完全拷贝一个对象，让其每一层的属性都和原对象无关，就需要用到深拷贝了。

简单一句话描述：完全复制对象的所有层级结构，包括嵌套的引用类型数据，新对象与原对象完全独立，不共享任何内存。

### 特点：
- 复制对象的每一层数据，嵌套的引用类型会被重新创建。
- 修改任何层级的内容，原对象和拷贝对象均互不影响。

## 常见深拷贝方法：
1.简易方法（有局限性）：

JSON.parse(JSON.stringify(原对象))
- 原理：先将对象转为 JSON 字符串（剥离引用关系），再解析为新对象。
- 局限性：无法复制函数、正则、日期、循环引用等特殊类型。

2.手动递归实现：

递归遍历对象的每一层，对引用类型进行逐层复制（需处理各种数据类型）。

3.工具库方法：
- Lodash 的 _.cloneDeep(原对象)（推荐，处理全面）。

## 手写一个简版的深拷贝函数
实现要求
- 1.简易版不处理特殊对象类型和循环引用
- 2.深层嵌套对象的完全独立拷贝,修改克隆对象不影响原对象的任何层级
- 3.处理基本数据类型和引用数据类型

```js
function deepClone(obj) {
   if(typeof obj !== 'object' && obj !== null) {
    return obj;
  }
  if(Array.isArray(obj)) {
    const arr = []
    obj.forEach((item, index) => {
      arr[index] = deepClone(item)
    })
    return arr
  }else {
    const newObj = {}
    for(let key in obj) {
      if (obj.hasOwnProperty(key)) {
        newObj[key] = deepClone(obj[key])
      }
    }
    return newObj
  }
}

const obj1 = {a: 1, b: {c: 2}}
const copy3 = deepClone(obj1) 
copy3.a = 10
copy3.b.c = 20

console.log(obj1);

const arr1 = [1, [2, 3]];
const copy4 = deepClone(arr1);
copy4[0] = 10;
copy4[1][0] = 20;

console.log(arr1);
```