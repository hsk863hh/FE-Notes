## 什么是防抖
在 JavaScript 中，防抖（Debounce） 是一种优化高频触发事件的技术，其核心思想是：当事件被频繁触发时，只在最后一次触发后的指定时间内执行一次回调函数，避免函数被多次无效调用，从而提升性能。

以搜索框为例，如果没有防抖，那么在用户输入的过程中，每输入一个字符，就会触发一次事件，这样会频繁地执行某些操作，导致性能下降。

所以，为了避免频繁触发事件，我们可以使用防抖，在用户停止输入一段时间后才执行某个操作

## 应用场景
防抖常用于处理那些可能被高频触发的事件，例如：

- 输入框实时搜索（避免用户输入过程中频繁发送请求）
- 窗口大小调整（resize 事件）
- 滚动事件（scroll）
- 按钮点击（防止用户快速多次点击）

## 基本原理

- 1.当事件触发时，不立即执行回调，而是设置一个定时器。
- 2.如果在定时器倒计时结束前，事件再次被触发，则清除上一次的定时器，重新设置新的定时器。
- 3.只有当事件停止触发并等待指定时间后，定时器才会执行回调函数。


## 实现代码
要点
- 使用闭包保存定时器状态，实现状态持久化
- 每次调用都要清除之前的定时器，重新计时
- 正确处理this指向，使用apply绑定上下文
- 支持immediate模式，第一次触发立即执行


```js
function debounce(fn, delay, immediate) {
  let timer = null;
  return function (...args) { 
    if(timer) {
      clearTimeout(timer);
    }
    if(immediate && !timer) {
      fn.apply(this, args)
    }
    timer = setTimeout(() => {
      if(!immediate) {
        fn.apply(this, args)
      }
      timer = null;
    }, delay)
    return timer;
  }
}
```

## 什么是节流
在 JavaScript 中，节流（Throttle） 是另一种优化高频触发事件的技术，其核心思想是：在指定时间间隔内，无论事件触发多少次，只执行一次回调函数，保证函数按固定频率执行，避免过度调用。

## 应用场景
节流适用于事件持续触发且需要定期响应的场景，例如：

- 滚动事件（定期计算滚动位置、加载更多内容）
- 鼠标移动 / 拖拽（定期更新元素位置）
- 窗口大小调整（定期重新布局）
- 高频点击（限制点击响应频率）

## 基本原理
1. 设定一个时间间隔（如 100ms）。
2. 事件第一次触发时，立即执行回调，并记录当前时间。
3. 后续触发时，检查当前时间与上次执行时间的差值：
- 若差值小于设定间隔，不执行。
- 若差值大于等于设定间隔，执行回调并更新上次执行时间。

## 实现代码
要点
- 设置时间间隔参数
- 在时间间隔内只执行一次
- 支持首次立即执行

```js
function throttle(fn, delay, immediate) {
  let timer = null;
  return function (...args) {
    if(immediate && !timer) {
      fn.apply(this, args)
    }
    if(!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        timer = null
      }, delay)
    }
    return timer;
  }
}
```


## 防抖与节流的区别
防抖（Debounce）：触发后等待 delay 再执行，若期间再次触发则重新计时（最终只执行一次）。
- 👉 场景：输入搜索、窗口 resize。

节流（Throttle）：每隔 delay 时间最多执行一次，无论事件触发多少次（固定频率执行）。
- 👉 场景：滚动加载、鼠标移动绘图。
